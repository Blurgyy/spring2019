|实验名称|黑白图像的直方图均衡化|
|:---:|:---:|
|实验时间|2019 年 5 月 15 日|
|姓名|张高阳|
|班级|电子信息科学与技术|
|学号|16020021054|

## 实验目的、内容
本次实验对一幅黑白图像做直方图均衡化，并对均衡化前后的两幅黑白图像做出视觉上的比较。

## 相关背景知识介绍
对于一幅黑白图像，其每一个像素的灰度可用一个字节(`8 bit`)来表示，灰度值域为 `0-255` 共 `256` 个值。灰度直方图即为对每一个灰度设置一个计数器，遍历整幅图像并分别计数。对于一些视觉上看起来不够鲜明的图片，对其统计灰度直方图，会发现其灰度分布在一个值域 $[l,r]$ 内。通过将该图像的灰度值域放大到整个 $[0,255]$ 范围内，将更加符合人眼的灰度辨认能力，图像细节部分可以显示的更清楚。

直方图均衡化的过程是建立一个灰度-灰度映射，将值域范围较小的原图像映射到值域范围更大的新图像上。记灰度为 $k$ 的像素共有 $cnt_k$ 个，令 $f_k=\Sigma_{i=0}^{k}cnt_i$ ，则灰度 $k$ 映射成的新的灰度 $k’$ 为 
$$k’=\frac{f_k}{\Sigma_{i=0}^{255}cnt_k}=\frac{f_k}{f_{255}}$$

则遍历图像，将旧的灰度按照映射 $k\rarr k'$ 映射为新的灰度，即得到新的图像。



## 代码

```c++
#include <bits/stdc++.h>
#include <opencv2/opencv.hpp>
using namespace std;
using namespace cv;
const int max_grayscale = 256;

int mp[max_grayscale];

int main(int argc, char **argv){
    if(argc != 2){
        printf("Usage:\n\t$PROGRAM_NAME $IMG_FILE_NAME\n");
        return -1;
    }
    Mat img = imread(argv[1], IMREAD_GRAYSCALE);
    int rows = img.rows;
    int cols = img.cols;
    Mat nimg = Mat(rows, cols, CV_8UC1);
    memset(mp, 0, sizeof(mp));
    for(int i = 0; i < rows; ++ i){
        uchar *x = img.ptr<uchar>(i);
        for(int j = 0; j < cols; ++ j){
            mp[x[j]] ++;
        }
    }
    for(int i = 1; i < max_grayscale; ++ i){
        mp[i] += mp[i-1];
    }
    for(int i = 0; i < max_grayscale; ++ i){
        mp[i] = (255.0 * mp[i]) / (1.0 * mp[max_grayscale-1]) + 0.5;
    }
    for(int i = 0; i < rows; ++ i){
        uchar *x = img.ptr<uchar>(i);
        uchar *y = nimg.ptr<uchar>(i);
        for(int j = 0; j < cols; ++ j){
            y[j] = mp[x[j]];
        }
    }
    Mat showimg = Mat(rows, cols * 2, CV_8UC1);
    for(int i = 0; i < rows; ++ i){
        uchar *x = img.ptr<uchar>(i);
        uchar *y = nimg.ptr<uchar>(i);
        uchar *z = showimg.ptr<uchar>(i);
        for(int j = 0; j < cols * 2; ++ j){
            if(j < cols) {
                z[j] = x[j];
            }
            else {
                z[j] = y[j];
            }
        }
    }
    imshow("histogram", showimg);
    waitKey();
    return 0;
}
```
## 运行结果
|                  原图                  |                        均衡化                        |
| :------------------------------------: | :--------------------------------------------------: |
| ![Original “Lena original”][lena_orig] | ![Processed “Lena after processing”][lena_processed] |
| ![Original “整挺好 original”][zth_orig] | ![Processed “整挺好 after processing”][zth_processed] |
| ![ame_orig][ame_orig] | ![ame_proc][ame_proc] |



## 结果分析

直方图均衡化可以使图片细节更容易辨认，因为这一操作将灰度值域放大到了整个 `0-255` 范围内。对大部分照片（图`1`、图`3`），这一操作可以提升人眼观察时的舒适度，但对特定图像（比如动漫等艺术作品），将灰度放大到 `0-255` 范围内的观赏效果很有可能会变差（`图2`）。

## 出现的问题、解决方法及体会
一开始通过 `opencv` 的函数 `imread` 读取图像时，第二个参数使用了默认的 `IMREAD_COLOR` ，造成读取的单通道图片被存成了三通道图片，造成后期遍历图片进行直方图均衡化时，仅操作了图像的左侧 $\frac{1}{3}$ 。发现问题后，我通过加上参数 `IMREAD_GRAYSCALE` 解决了这一问题。



[lena_orig]:http://106.14.194.215/imghost/histogram/bw/lena_bw_orig.jpg	"1. Lena Original"
[lena_processed]:http://106.14.194.215/imghost/histogram/bw/lena_bw.jpg	"1. Lena Processed"

[zth_orig]:http://106.14.194.215/imghost/histogram/bw/zth_small_bw_orig.jpg	"2. Orignal"
[zth_processed]:http://106.14.194.215/imghost/histogram/bw/zth_small_bw.jpg	"2. Processed"

[ame_orig]:http://106.14.194.215/imghost/histogram/bw/ame_orig.jpg	"3. Processed"
[ame_proc]:http://106.14.194.215/imghost/histogram/bw/ame_proc.jpg "3. Processed"