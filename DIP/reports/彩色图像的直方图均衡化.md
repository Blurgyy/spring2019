|实验名称|彩色图像的直方图均衡化|
|:---:|:---:|
|实验时间|2019 年 5 月 22 日|
|姓名|张高阳|
|班级|电子信息科学与技术|
|学号|16020021054|

## 实验目的、内容
本次实验对彩色图像做直方图均衡化，并对均衡化前后的两幅彩色图像做出比较。

## 相关背景知识介绍
对于彩色图像的直方图均衡化，如果直接在 `RGB` 空间内对三个通道分别进行直方图均衡化，的确可以得到细节更鲜明的图像，但是图像的颜色会出现极大的失真，所以这种做法是错误的。
正确的做法是，先将原始的 `RGB` 空间中的图像转换到 `HSI` 空间中，然后原图像中的色彩信息全部存在 `H`、 `S` 两个通道中，通道 `I` 中是原图像的亮度信息。这时对通道 `I` 做单通道的直方图均衡化，然后将均衡化后的 `HSI` 图像转换回 `RGB` 空间，即可得到直方图均衡化后的彩色图像。

## 代码

```py
#!/usr/bin/python
#-*- coding: utf-8 -*-
__author__ = "zgy";

import cv2 as cv
import sys
import math

def rgb2hsi(imIn):
    try:
        ret = imIn.copy();
        B, G, R = cv.split(imIn);
        B = B / 255.0;
        G = G / 255.0;
        R = R / 255.0;
        eps = 1e-8;
        pi = math.acos(-1.0);
        rows, cols = imIn.shape[0], imIn.shape[1];
        for i in range(rows):
            for j in range(cols):
                b = B[i, j];
                g = G[i, j];
                r = R[i, j];
                theta = 0;
                H = 0;
                S = 0;
                I = (r + g + b) / 3.0;
                if(I < eps):
                    S = 0;
                else:
                    S = 1 - (3 * min(r, g, b)) / (r + g + b);
                    if(r == g and g == b):
                        H = 0;
                    else:
                        theta = math.acos((0.5 * ((r-g) + (r-b))) / math.sqrt(((r-g) ** 2 + (r-b) * (g-b))));
                        if(b <= g):
                            H = theta;
                        else:
                            H = 2 * pi - theta;
                H /= 2 * pi;
                H *= 255;
                S *= 255;
                I *= 255;
                assert(H >= 0 and H <= 255);
                assert(S >= 0 and S <= 255);
                assert(I >= 0 and I <= 255);
                ret[i, j, 0] = H;
                ret[i, j, 1] = S;
                ret[i, j, 2] = I;
        return ret;
    except Exception as e:
        print("rgb2hsi(): %s" % (e));

def hsi2rgb(imIn):
    try:
        ret = imIn.copy();
        rows, cols = ret.shape[0], ret.shape[1];
        H, S, I = cv.split(imIn);
        H = H / 255.0;
        S = S / 255.0;
        I = I / 255.0;
        eps = 1e-8;
        pi = math.acos(-1.0);
        for i in range(rows):
            for j in range(cols):
                B = 0;
                G = 0;
                R = 0;
                if S[i, j] < eps:
                    R = I[i, j];
                    G = I[i, j];
                    B = I[i, j];
                else:
                    H[i, j] *= 360;
                    if(0 <= H[i, j] and H[i, j] <= 120):
                        H[i, j] = H[i, j] / 180 * pi;
                        R = I[i, j] * (1 + (S[i, j] * math.cos(H[i, j])) / (math.cos(pi/3 - H[i, j])));
                        B = I[i, j] * (1 - S[i, j]);
                        G = 3 * I[i, j] - (R + B);
                    elif(120 < H[i, j] and H[i, j] <= 240):
                        H[i, j] -= 120;
                        H[i, j] = H[i, j] / 180 * pi;
                        G = I[i, j] * (1 + (S[i, j] * math.cos(H[i, j])) / (math.cos(pi/3 - H[i, j])));
                        R = I[i, j] * (1 - S[i, j]);
                        B = 3 * I[i, j] - (R + G);
                    elif(240 < H[i, j] and H[i, j] <= 360):
                        H[i, j] -= 240;
                        H[i, j] = H[i, j] / 180 * pi;
                        B = I[i, j] * (1 + (S[i, j] * math.cos(H[i, j])) / (math.cos(pi/3 - H[i, j])));
                        G = I[i, j] * (1 - S[i, j]);
                        R = 3 * I[i, j] - (G + B);
                    else:
                        raise Exception("H =", H[i, j]);
                if(B > 1):
                    B = 1;
                if(G > 1):
                    G = 1;
                if(R > 1):
                    R = 1;
                B = int(B * 255);
                G = int(G * 255);
                R = int(R * 255);
                # print(B, G, R);
                assert(B >= 0 and B <= 255);
                assert(G >= 0 and G <= 255);
                assert(R >= 0 and R <= 255);
                ret[i, j, 0] = B;
                ret[i, j, 1] = G;
                ret[i, j, 2] = R;
        return ret;
    except Exception as e:
        print("hsi2rgb(): %s" % (e));

def histogram_eq(imIn, GRAYSCALE_range = 256):
    try:
        ret = imIn.copy();
        mp = [];
        for i in range(GRAYSCALE_range):
            mp.append(0);
        rows, cols = imIn.shape[0], imIn.shape[1];
        for i in range(rows):
            for j in range(cols):
                mp[imIn[i, j]] += 1;
        for i in range(1, GRAYSCALE_range):
            mp[i] += mp[i-1];
        for i in range(GRAYSCALE_range):
            mp[i] = 1.0 * (GRAYSCALE_range -1) * mp[i] / mp[GRAYSCALE_range-1] + 0.5;
            mp[i] = int(mp[i]);
        for i in range(rows):
            for j in range(cols):
                ret[i, j] = mp[ret[i, j]];
        return ret;
    except Exception as e:
        print("histogram_eq(): %s" % e);

def main():
    try:
        if(len(sys.argv) != 2 and len(sys.argv) != 3):
            raise Exception("invalid argument");
        imIn = cv.imread(sys.argv[1]);
        hsiImg = rgb2hsi(imIn);
        hsiImg[:, :, 2] = histogram_eq(hsiImg[:, :, 2]);
        imOut = hsi2rgb(hsiImg);
        if(len(sys.argv) == 3):
            cv.imwrite(sys.argv[2], imOut);
        cv.imshow("original", imIn);
        cv.imshow("test", imOut);
        cv.waitKey(0);
    except Exception as e:
        print("main(): %s" % (e));


if(__name__ == "__main__"):
    main();
```

## 运行结果
|原始图像|均衡化|
|:---:|:---:|
| ![Original][lena_orig] | ![Processed][lena_proc] |
| ![Original][zth_orig] | ![Processed][zth_proc] |
| ![Original][life_orig] | ![Processed][life_proc] |

## 结果分析
经过直方图均衡化操作后，图像的细节可以被放大，使图像观看起来更鲜明（图`1`）；但对于一些色彩信息较为简单的图像，均衡化结果可能并不如原图观看效果更好（图`2`）；一些照片均衡化后的结果会看起来像画作（图`3`）。

## 出现的问题、解决方法及体会
一开始做出的均衡化后的图像的颜色出现了严重失真。研究后发现在实现 `RGB` 与 `HSI` 通道的相互转换的函数中有的计算结果会出现越界(`>255`)。将最大值限制到 `255` 后，解决了这一问题。


[lena_orig]:http://106.14.194.215/imghost/histogram/rgb/lena_orig.tiff	"1. Lena Original"
[lena_proc]:http://106.14.194.215/imghost/histogram/rgb/lena_proc.jpg	"1. Lena Processed"


[zth_orig]:http://106.14.194.215/imghost/histogram/rgb/zth_orig.jpg	"2. Original"
[zth_proc]:http://106.14.194.215/imghost/histogram/rgb/zth_proc.jpg "2. Processed"

[life_orig]:http://106.14.194.215/imghost/histogram/rgb/life_orig.jpg	"3. Orignal"
[life_proc]:http://106.14.194.215/imghost/histogram/rgb/life_proc.jpg	"3. Processed"
